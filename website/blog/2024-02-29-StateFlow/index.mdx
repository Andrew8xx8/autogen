---
title: StateFlow - Build LLM Workflows with Customized State-Oriented Transition Function in GroupChat
authors: yiranwu
tags: [LLM, research]
---

**TL;DR:**: Introduce Stateflow, a task-solving paradigm that conceptualizes complex task-solving processes backed by LLMs as state machines.
Introduce how to use GroupChat to realize such an idea with a customized speaker selection function.

The paper is coming soon!

## Introduction
LLMs have increasingly been employed to solve complex, multi-step tasks, e.g., tasks that require a sequence of complex reasoning
and interacting with external environments and tools. To facilitate the development of such applications, we introduce **StateFlow**, a new paradigm
that conceptualizes complex task-solving processes backed by LLMs as state machines. With proper construction of states and definition of
state transitions, we can ground the progress of task-solving, ensuring clear tracking and management of LLMs' responses throughout the task-solving process.

We evaluate **StateFlow** on the SQL task and Bash task from the InterCode benchmark. 
The results demonstrate the advantages of **StateFlow** over existing methods in terms of both effectiveness and efficiency.
For instance, in the SQL task with GPT-4-turbo, **StateFlow** improves the success rate by 10% compared to ReAct prompting, while reducing costs by a factor of 4.  

## Implement StateFlow With GroupChat
AutoGen GroupChat can be used to build a state-oriented workflow. Previous blog on [FSM Group Chat](/blog/2024-02-11-FSM-GroupChat)
introduces a way how to define a graph of agents, and use natural language to describe the transition conditions of the FSM in the agent's `description` parameter.
GroupChat also allows passing in a customized speaker selection function to the `speaker_selection_method` to customize the selection rule for the next speaker.
These transitions can be based on the current speaker and static checking of the context history (for example, checking if 'Error' is in the last message).

We present an example of how to build a state-oriented workflow using GroupChat.
We define a custom speaker selection function to be passed into the `speaker_selection_method` parameter of the GroupChat.
Here, the task is to retrieve research papers related to a given topic, and create a markdown table for these papers.

![StateFlow Example](./img/sf_example_1.png)


We define the following agents:
- Initializer: Start the workflow by sending a task.
- Coder: Retrieve papers from the internet by writing code.
- Executor: Execute the code.
- Scientist: Read the papers and write a summary.


```python
# Define the agents, the code is for illustration purposes and is not executable.
initializer = autogen.UserProxyAgent(
   name="Init"
)
coder = autogen.AssistantAgent(
   name="Coder",
   system_message="""You are the Coder. Write Python Code to retrieve papers from arxiv.."""
)
executor = autogen.UserProxyAgent(
   name="Executor",
   system_message="Executor. Execute the code written by the Coder and report the result.",
)
scientist = autogen.AssistantAgent(
   name="Scientist",
   system_message="""You are the Scientist. Please categorize papers after seeing their abstracts printed and create a markdown table with Domain, Title, Authors, Summary and Link. Return 'TERMINATE' in the end.""",
)
```

In the Figure, we define a simple workflow for research with 4 states: Init, Retrieve, Reserach and End. Within each state, we will call different agents to perform the tasks.
- Init: We use the initializer to start the workflow.
- Retrieve: We will first call the coder to write code and then call the executor to execute the code.
- Research: We will call the scientist to read the papers and write a summary.
- End: We will end the workflow.


Then we define a customized function to control the transition between states:
```python
def state_transition(last_speaker, groupchat):
   messages = groupchat.messages


   if last_speaker is initializer:
       # init -> retrieve
       return coder
   elif last_speaker is coder:
       # retrieve: action 1 -> action 2
       return executor
   elif last_speaker is executor:
       if messages[-1]["content"] == "exitcode: 1":
           # retrieve --(execution failed)--> retrieve
           return coder
       else:
           # retrieve --(execution success)--> research
           return scientist
   elif last_speaker == "Scientist":
       # research -> end
       return None


groupchat = autogen.GroupChat(
   agents=[initializer, coder, executor, scientist],
   messages=[],
   max_round=20,
   speaker_selection_method=state_transition,
)
```


We recommend implementing the transition logic for each speaker in the customized function. In analogy to a state machine, a state transition function determines the next state based on the current state and input.
Instead of returning an `Agent` class representing the next speaker, we can also return a string from `['auto', 'manual', 'random', 'round_robin']` to select a default method to use.
For example, we can always default to the built-in `auto` method to employ a LLM-based groupchat manager to select the next speaker.
When returning `None`, the groupchat will terminate.



## For Further Reading
* [StateFlow notebook](https://microsoft.github.io/autogen/docs/notebooks/agentchat_groupchat_stateflow/)
* [GroupChat with Customized Speaker Selection notebook](https://microsoft.github.io/autogen/docs/notebooks/agentchat_groupchat_customized/)
* [FSM Group Chat](https://microsoft.github.io/autogen/blog/2024/02/11/FSM-GroupChat/)
* [Documentation about `autogen`](/docs/Getting-Started)
